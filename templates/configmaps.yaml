apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "gitfence.name" . }}-entropy-script
  namespace: {{ .Release.Namespace }}
data:
  entropy.sh: |-
    #! /bin/sh

    # Ensure there's enough entropy available
    printf "%s\n" "Ensuring there's sufficient entropy avaiable for GPG and Age key generation..."
    printf "%s\n" "Available entropy before seeding random: $(cat /entropy-avail)"
    rngd -r /dev-urandom -o /dev-random --background --fill-watermark={{ include "gitfence.entropyWatermark" . }}
    while [ $(cat /entropy-avail) -lt {{ include "gitfence.entropyWatermark" . }} ]; do
      dd bs=1M count=1 if=/dev-zero of=/tmp/rnd conv=fsync &>/dev/null
    done
    printf "%s\n\n" "Available entropy after seeding random: $(cat /entropy-avail)"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "gitfence.name" . }}-crypto-script
  namespace: {{ .Release.Namespace }}
data:
  gitfence.sh: |-
    #! /bin/sh

    printf "%s\n" "Configuring kubectl with service account..."
    # Use the service account context
    kubectl config set-cluster k8s --server=https://kubernetes.default --certificate-authority=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    kubectl config set-credentials gitfence --token=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    kubectl config set-context k8s --cluster=k8s --user=gitfence
    kubectl config use-context k8s
    printf "%s\n" "Checking cluster permissions..."
    printf "%s" "Can {{ include "gitfence.name" . }} create secrets in {{ .Release.Namespace }} namespace? "
    kubectl auth can-i create secrets --namespace {{ .Release.Namespace }}
    if [ $? -ne 0 ]; then
      logger -s "Insufficient permissions; cannot create secrets!"
      exit 1
    fi

    # Default encryption method is GPG; so check if Age should be used instead
    if {{ not .Values.age.enabled }}; then
      # Check if the "gitfence-gpgkey" secret already exists
      if {{ .Values.gpg.overwriteKey }}; then
        printf "%s\n" "Deleting any previous gitfence-gpgkey and gitfence-gpgpub secrets..."
        kubectl delete secret gitfence-gpgkey gitfence-gpgkey --namespace {{ .Release.Namespace }} --ignore-not-found
        kubectl delete secret gitfence-gpgkey gitfence-gpgpub --namespace {{ .Release.Namespace }} --ignore-not-found
      fi
      printf "\n%s\n" "Checking for existence of gitfence-gpgkey secret..."
      kubectl get secret gitfence-gpgkey --namespace {{ .Release.Namespace }}  2>/dev/null
      if [ $? -eq 200 ]; then
        logger -s "Skipping GPG key creation, as gitfence-gpgkey already exists!"
        exit 1
      else
        printf "%s\n\n" "Couldn't find any previous gitfence-gpgkey secret; a new key will be generated"
      fi

      # Setup the GPG home directory
      printf "%s\n" "Setting up GPG home directory..."
      mkdir -p ${GNUPGHOME}
      cp -f {{ .Values.global.userHome }}/gpg.conf ${GNUPGHOME}/gpg.conf
      cp -f {{ .Values.global.userHome }}/gpg.batch ${GNUPGHOME}/gpg.batch
      chmod 700 ${GNUPGHOME}
      printf "%s\n\n" "GPG home directory ${GNUPGHOME} is configured"

      # Create a new GPG key
      printf "%s\n" "Generating a new GPG key..."
      # gpg --batch --full-generate-key ${GNUPGHOME}/gpg.batch
      gpg --quick-generate-key --batch --passphrase "" \
        "{{- .Values.gpg.name }} ( {{- .Values.gpg.comment -}} )" \
        default default never

      # Get the fingerprint of the GPG key
      printf "%s\n" "Getting fingerprint of GPG key..."
      KEY_FP=$(gpg --with-colons --fingerprint {{ quote .Values.cluster }} | grep fpr | cut -d ':' -f 10 | head -1)

      # Export the GPG private key, and store it as a secret
      printf "%s\n" "Exporting & storing GPG private key, as a secret..."
      gpg --export-secret-keys --armor "${KEY_FP}" | kubectl create secret generic gitfence-gpgkey \
          --namespace={{ .Release.Namespace }} --from-file=gpg.key.asc=/dev/stdin

      # Export the GPG public key, and store it as a secret
      printf "%s\n" "Exporting & storing GPG public key, as a secret..."
      gpg --export --armor "${KEY_FP}" | kubectl create secret generic gitfence-gpgpub \
          --namespace={{ .Release.Namespace }} --from-file=gpg.pub.asc=/dev/stdin

      # Write the GPG public key to standard output
      printf "\n%s\n" "Listing GPG public keys..."
      gpg --list-keys --fingerprint
      printf "%s\n" "Printing GPG public key..."
      kubectl get secret gitfence-gpgpub --namespace={{ .Release.Namespace }} \
        --ignore-not-found -o jsonpath="{.data.*}" | base64 -d
    else
      # Check if the "gitfence-agekey" secret already exists
      if {{ .Values.age.overwriteKey }}; then
        printf "%s\n" "Deleting any previous gitfence-agekey and gitfence-agepub secrets..."
        kubectl delete secret gitfence-agekey gitfence-agekey \
          --namespace {{ .Release.Namespace }} --ignore-not-found
        kubectl delete secret gitfence-agekey gitfence-agepub \
          --namespace {{ .Release.Namespace }} --ignore-not-found
      fi
      printf "\n%s\n" "Checking for existence of gitfence-agekey secret..."
      kubectl get secret gitfence-agekey --namespace {{ .Release.Namespace }} 2>/dev/null
      if [ $? -eq 200 ]; then
        logger -s "Skipping Age key creation, as gitfence-agekey already exists!"
        exit 1
      else
        printf "%s\n\n" "Couldn't find any previous gitfence-agekey secret; a new key will be generated"
      fi

      # Setup the Age working directory
      printf "%s\n" "Setting up Age working directory..."
      AGEHOME={{ .Values.global.userHome }}/age
      mkdir -p ${AGEHOME}
      chmod 700 ${AGEHOME}
      printf "%s\n\n" "Age working directory ${AGEHOME} is configured"

      # Create a new Age key
      age-keygen -o ${AGEHOME}/age.agekey

      # Store the Age private key, as a secret
      printf "%s\n" "Storing Age private key, as a secret..."
      cat ${AGEHOME}/age.agekey | \
          kubectl -n default create secret generic gitfence-agekey \
            --namespace={{ .Release.Namespace }} --from-file=age.key=/dev/stdin

      # Store the Age public key, as a secret
      printf "%s\n" "Storing Age public key, as a secret..."
      cat ${AGEHOME}/age.agekey | awk '/public key/ {print $4}' | \
          kubectl create secret generic gitfence-agepub \
            --namespace={{ .Release.Namespace }} --from-file=age.pub=/dev/stdin

      # Write the Age public key to standard output
      printf "\n%s\n" "Printing Age public key..."
      kubectl get secret gitfence-agepub --namespace={{ .Release.Namespace }} \
        --ignore-not-found -o jsonpath="{.data.*}" | base64 -d
    fi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "gitfence.name" . }}-gpg-conf
  namespace: {{ .Release.Namespace }}
data:
  gpg.conf: |-
    # Making sure gpg is appropriately configured (~/.gnupg/gpg.conf)
    #
    # The default expiration time to use for signature expiration
    default-sig-expire 0

    # The default expiration time to use for key signature expiration
    default-cert-expire 0

    # This option can be used to change the default algorithms for key generation
    default-new-key-algo "ed25519/cert,sign+cv25519/encr"

    # This preference list is used for new keys and becomes the default for
    # "setpref" in the edit menu
    default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES ZLIB BZIP2 ZIP Uncompressed

    # Suppress the initial copyright message
    no-greeting

    # Enable advance algorithms
    expert

    # Disable inclusion of the version string in ASCII armored output
    no-emit-version

    # Disable comment string in clear text signatures and ASCII armored messages
    no-comments

    # Identify weak options
    disable-cipher-algo IDEA 3DES CAST5 TWOFISH AES192
    weak-digest SHA1
    weak-digest RIPEMD160
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "gitfence.name" . }}-gpg-batch
  namespace: {{ .Release.Namespace }}
data:
  gpg.batch: |-
    # This method will not be used, but documented for reference
    %no-protection
    Key-Type: eddsa
    Key-Curve: ed25519
    Key-Usage: sign
    Subkey-Type: ecdh
    Subkey-Curve: cv25519
    Subkey-Usage: encrypt
    Expire-Date: 0
    Name-Comment: {{ quote .Values.gpg.comment }}
    Name-Real: {{ quote .Values.cluster }}
    Preferences: SHA512 SHA384 SHA256 SHA224 AES256 AES ZLIB BZIP2 ZIP Uncompressed
    %commit
---

